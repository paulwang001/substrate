// Copyright 2020 Parity Technologies (UK) Ltd.
// This file is part of Substrate.
//
// Substrate is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Substrate is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Substrate.  If not, see <http://www.gnu.org/licenses/>.

//! `NetworkBehaviour` implementation which handles incoming block requests.
//!
//! Every request is coming in on a separate connection substream which gets
//! closed after we have sent the response back. Incoming requests are encoded
//! as protocol buffers (cf. `api.v1.proto`).

#![allow(unused)]

use bytes::Bytes;
use codec::{Encode, Decode};
use crate::{
    chain::Client,
    config::ProtocolId,
    protocol::{message::{self, BlockAttributes}},
    schema,
};
use futures::{future::BoxFuture, prelude::*, stream::FuturesUnordered};
use futures_timer::Delay;
use libp2p::{
    core::{
        ConnectedPoint,
        Multiaddr,
        PeerId,
        connection::ConnectionId,
        upgrade::{InboundUpgrade, OutboundUpgrade, ReadOneError, UpgradeInfo, Negotiated},
        upgrade::{DeniedUpgrade, read_one, write_one}
    },
    swarm::{
        NegotiatedSubstream,
        NetworkBehaviour,
        NetworkBehaviourAction,
        NotifyHandler,
        OneShotHandler,
        OneShotHandlerConfig,
        PollParameters,
        SubstreamProtocol
    }
};
use prost::Message;
use sp_runtime::{generic::BlockId, traits::{Block, Header, One, Zero}};
use std::{
    cmp::min,
    collections::{HashMap, VecDeque},
    io,
    iter,
    marker::PhantomData,
    pin::Pin,
    sync::Arc,
    time::Duration,
    task::{Context, Poll}
};
use void::{Void, unreachable};
use wasm_timer::Instant;
use sp_runtime::traits::NumberFor;

// Type alias for convenience.
pub type Error = Box<dyn std::error::Error + 'static>;


pub struct PublishBehaviour<B> {
    marker:PhantomData<B>
}

impl<B> NetworkBehaviour for PublishBehaviour<B>
    where
        B: Block
{
    type ProtocolsHandler = OneShotHandler<InboundProtocol<B>, OutboundProtocol<B>, NodeEvent<B>>;
    type OutEvent = Event<B>;
    fn new_handler(&mut self) -> Self::ProtocolsHandler {
        let p = InboundProtocol {
            max_request_len: 10,
            protocol: "/test/msg/1".as_bytes().to_owned().into(),
            marker: PhantomData,
        };
        let mut cfg = OneShotHandlerConfig::default();
        OneShotHandler::new(SubstreamProtocol::new(p, ()), cfg)
    }

    fn addresses_of_peer(&mut self, _: &PeerId) -> Vec<Multiaddr> {
        Vec::new()
    }

    fn inject_connected(&mut self, _peer: &PeerId) {

    }

    fn inject_disconnected(&mut self, _peer: &PeerId) {
    }

    fn inject_connection_established(&mut self, peer_id: &PeerId, id: &ConnectionId, _: &ConnectedPoint) {

    }

    fn inject_connection_closed(&mut self, peer_id: &PeerId, id: &ConnectionId, _: &ConnectedPoint) {

    }

    fn inject_event(
        &mut self,
        peer: PeerId,
        connection_id: ConnectionId,
        node_event: NodeEvent<B>
    )
    {

    }

    fn poll(&mut self, cx: &mut Context, _: &mut impl PollParameters)
            -> Poll<NetworkBehaviourAction<OutboundProtocol<B>, Event<B>>>
    {
        Poll::Pending
    }
}


/// Event generated by the block requests behaviour.
#[derive(Debug)]
pub enum Event<B: Block> {
    /// A request came and we have successfully answered it.
    AnsweredRequest {
        /// Peer which has emitted the request.
        peer: PeerId,
        /// Time elapsed between when we received the request and when we sent back the response.
        total_handling_time: Duration,
    },

    /// A response to a block request has arrived.
    Response {
        peer: PeerId,
        response: message::BlockResponse<B>,
        /// Time elapsed between the start of the request and the response.
        request_duration: Duration,
    },

    /// A request has been cancelled because the peer has disconnected.
    /// Disconnects can also happen as a result of violating the network protocol.
    ///
    /// > **Note**: This event is NOT emitted if a request is overridden by calling `send_request`.
    /// > For that, you must check the value returned by `send_request`.
    RequestCancelled {
        peer: PeerId,
        /// Time elapsed between the start of the request and the cancellation.
        request_duration: Duration,
    },

    /// A request has timed out.
    RequestTimeout {
        peer: PeerId,
        /// Time elapsed between the start of the request and the timeout.
        request_duration: Duration,
    }
}

/// Output type of inbound and outbound substream upgrades.
#[derive(Debug)]
pub enum NodeEvent<B: Block> {
    Push {
        marker:PhantomData<B>
    },
    Pull,
}

/// Substream upgrade protocol.
///
/// We attempt to parse an incoming protobuf encoded request (cf. `Request`)
/// which will be handled by the `BlockRequests` behaviour, i.e. the request
/// will become visible via `inject_node_event` which then dispatches to the
/// relevant callback to process the message and prepare a response.
#[derive(Debug, Clone)]
pub struct InboundProtocol<B> {
    /// The max. request length in bytes.
    max_request_len: usize,
    /// The protocol to use during upgrade negotiation.
    protocol: Bytes,
    /// Type of the block.
    marker: PhantomData<B>,
}

impl<B: Block> UpgradeInfo for InboundProtocol<B> {
    type Info = Bytes;
    type InfoIter = iter::Once<Self::Info>;

    fn protocol_info(&self) -> Self::InfoIter {
        iter::once(self.protocol.clone())
    }
}

impl<B, T> InboundUpgrade<T> for InboundProtocol<B>
    where
        B: Block,
        T: AsyncRead + AsyncWrite + Unpin + Send + 'static
{
    type Output = NodeEvent<B>;
    type Error = ReadOneError;
    type Future = BoxFuture<'static, Result<Self::Output, Self::Error>>;

    fn upgrade_inbound(self, mut s: T, _: Self::Info) -> Self::Future {
        // This `Instant` will be passed around until the processing of this request is done.
        let handling_start = Instant::now();

        Box::pin(async move {
            let len = self.max_request_len;
            let vec = read_one(&mut s, len).await?;
            Ok(NodeEvent::Pull)
        })
    }
}

/// Substream upgrade protocol.
///
/// Sends a request to remote and awaits the response.
#[derive(Debug, Clone)]
pub struct OutboundProtocol<B: Block> {
    /// The serialized protobuf request.
    request: Vec<u8>,
    /// The original request. Passed back through the API when the response comes back.
    original_request: message::BlockRequest<B>,
    /// The max. response length in bytes.
    max_response_size: usize,
    /// The protocol to use for upgrade negotiation.
    protocol: Bytes,
}

impl<B: Block> UpgradeInfo for OutboundProtocol<B> {
    type Info = Bytes;
    type InfoIter = iter::Once<Self::Info>;

    fn protocol_info(&self) -> Self::InfoIter {
        iter::once(self.protocol.clone())
    }
}

impl<B, T> OutboundUpgrade<T> for OutboundProtocol<B>
    where
        B: Block,
        T: AsyncRead + AsyncWrite + Unpin + Send + 'static
{
    type Output = NodeEvent<B>;
    type Error = ReadOneError;
    type Future = BoxFuture<'static, Result<Self::Output, Self::Error>>;

    fn upgrade_outbound(self, mut s: T, _: Self::Info) -> Self::Future {
        Box::pin(async move {
            write_one(&mut s, &self.request).await?;
            let vec = read_one(&mut s, self.max_response_size).await?;
            Ok(NodeEvent::<B>::Pull)
        })
    }
}

#[cfg(test)]
mod tests {
    use futures::{channel::mpsc, prelude::*};
    use libp2p::identity::Keypair;
    use libp2p::Multiaddr;
    use libp2p::core::upgrade;
    use libp2p::core::transport::{Transport};
    use libp2p::noise;
    use libp2p::swarm::{Swarm, SwarmEvent};
    use std::{iter, time::Duration};
    use substrate_test_runtime_client::runtime::Block;
    use libp2p::tcp::TcpConfig;
    use super::PublishBehaviour;

    #[test]
    fn basic_publish_works() {
        env_logger::init();
        let protocol_name = "/test/publish/1";

        // Build swarms whose behaviour is `RequestResponsesBehaviour`.
        let mut swarms = (0..2)
            .map(|x| {
                let keypair = Keypair::generate_ed25519();

                let noise_keys = noise::Keypair::<noise::X25519Spec>::new()
                    .into_authentic(&keypair)
                    .unwrap();

                let transport = TcpConfig::default()
                    .upgrade(upgrade::Version::V1)
                    .authenticate(noise::NoiseConfig::xx(noise_keys).into_authenticated())
                    .multiplex(libp2p::yamux::YamuxConfig::default())
                    .boxed();

                let behaviour = {
                    // let (tx, mut rx) = mpsc::channel(64);

                    let b = super::PublishBehaviour::<Block>{
                        marker: Default::default()
                    };

                    // async_std::task::spawn(async move {
                    //     while let Some(rq) = rx.next().await {
                    //         // assert_eq!(rq.payload, b"this is a request");
                    //         // let _ = rq.pending_response.send(b"this is a response".to_vec());
                    //     }
                    // });

                    b
                };

                let mut swarm = Swarm::new(transport, behaviour, keypair.public().into_peer_id());
                let listen_addr: Multiaddr = format!("/ip4/127.0.0.1/tcp/3000{}",x ).parse().unwrap();

                Swarm::listen_on(&mut swarm, listen_addr.clone()).unwrap();
                (swarm, listen_addr)
            })
            .collect::<Vec<_>>();

        // Ask `swarm[0]` to dial `swarm[1]`. There isn't any discovery mechanism in place in
        // this test, so they wouldn't connect to each other.
        {
            let dial_addr = swarms[1].1.clone();
            Swarm::dial_addr(&mut swarms[0].0, dial_addr).unwrap();
        }

        // Running `swarm[0]` in the background until a `InboundRequest` event happens,
        // which is a hint about the test having ended.
        async_std::task::spawn({
            let (mut swarm, _) = swarms.remove(0);
            async move {
                loop {
                    match swarm.next_event().await {
                        SwarmEvent::Behaviour(super::Event::AnsweredRequest { .. }) => {
                            break
                        },
                        _ => {}
                    }
                }
            }
        });

        // Remove and run the remaining swarm.
        let (mut swarm, _) = swarms.remove(0);
        async_std::task::block_on(async move {

            loop {
                match swarm.next_event().await {
                    SwarmEvent::ConnectionEstablished { peer_id, .. } => {

                    }
                    SwarmEvent::Behaviour(super::Event::Response {..}) => {

                        break;
                    }
                    _ => {}
                }
            }
        });
    }
}